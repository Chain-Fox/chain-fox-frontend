/**
 * Direct PDF Export Service
 * Provides functionality to export data directly to PDF without using html2canvas
 * This avoids Content Security Policy issues
 */

import { jsPDF } from 'jspdf';
import autoTable from 'jspdf-autotable';

/**
 * Exports report data directly to PDF
 * @param {Object} report - The report data
 * @param {Array} issues - The issues data
 * @param {string} filename - Name of the PDF file to download
 * @param {Object} options - Additional options for PDF generation
 * @returns {Promise<boolean>} - Whether the export was successful
 */
export const exportReportToPDF = async (report, issues, filename = 'report.pdf', options = {}) => {
  if (!report) {
    console.error('Report data is not available');
    return false;
  }

  try {
    // Show loading state if provided
    if (options.onStart) {
      options.onStart();
    }

    console.log('Starting PDF export with jsPDF and autoTable...');

    // Create PDF instance
    const pdf = new jsPDF({
      orientation: 'portrait',
      unit: 'mm',
      format: 'a4',
      compress: true
    });

    // Set default font
    pdf.setFont('helvetica');

    // Page dimensions
    const pageWidth = pdf.internal.pageSize.getWidth();
    const pageHeight = pdf.internal.pageSize.getHeight();
    const margin = 20; // margin in mm
    const contentWidth = pageWidth - (margin * 2);

    // Format dates
    const auditDate = new Date(report.created_at).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });

    const completedDate = new Date(report.updated_at).toLocaleDateString('en-US', {
      year: 'numeric',
      month: 'long',
      day: 'numeric'
    });

    // Generate a unique report reference number
    const reportId = String(report.id || '');
    const reportRef = `CF-${reportId.substring(0, 8).toUpperCase()}-${new Date().getFullYear()}`;

    // Filter issues to exclude false positives
    const filteredIssues = issues.filter(issue => !issue.false_positive);

    // Count issues by severity
    const severityCounts = {
      critical: 0,
      high: 0,
      medium: 0,
      low: 0,
      info: 0
    };

    filteredIssues.forEach(issue => {
      const severity = issue.severity?.toLowerCase() || 'info';
      if (severityCounts.hasOwnProperty(severity)) {
        severityCounts[severity]++;
      }
    });

    // Group issues by file
    const issuesByFile = {};
    filteredIssues.forEach(issue => {
      const filePath = issue.file_path || 'Unknown File';
      if (!issuesByFile[filePath]) {
        issuesByFile[filePath] = [];
      }
      issuesByFile[filePath].push(issue);
    });

    // Process text to convert escape sequences to actual characters
    const processText = (text) => {
      if (!text) return '';
      return text
        .replace(/\\n/g, '\n')
        .replace(/\\t/g, '\t')
        .replace(/\\r/g, '\r')
        .replace(/\\\\/g, '\\')
        .replace(/\\"/g, '"')
        .replace(/\\'/g, "'");
    };

    // Helper function to add text with automatic line breaks
    const addWrappedText = (text, x, y, maxWidth, lineHeight = 7) => {
      if (!text) return y;

      const lines = pdf.splitTextToSize(text, maxWidth);
      pdf.text(lines, x, y);
      return y + (lines.length * lineHeight);
    };

    // Cover Page
    pdf.setFontSize(28);
    pdf.setTextColor(50, 50, 50);
    pdf.text('CODE SECURITY ASSESSMENT', pageWidth / 2, 60, { align: 'center' });

    pdf.setFontSize(16);
    pdf.text(report.repo_name, pageWidth / 2, 75, { align: 'center' });

    pdf.setFontSize(12);
    pdf.text(`Report Reference: ${reportRef}`, pageWidth / 2, 95, { align: 'center' });
    pdf.text(`Completed: ${completedDate}`, pageWidth / 2, 102, { align: 'center' });

    pdf.setFontSize(10);
    pdf.text('Generated by Chain-Fox Security Audit Platform', pageWidth / 2, 120, { align: 'center' });

    // Add logo placeholder
    pdf.setDrawColor(200, 200, 200);
    pdf.setFillColor(240, 240, 240);
    pdf.roundedRect(pageWidth / 2 - 20, 30, 40, 20, 2, 2, 'FD');
    pdf.setFontSize(12);
    pdf.setTextColor(100, 100, 100);
    pdf.text('CHAIN-FOX', pageWidth / 2, 43, { align: 'center' });

    // Add new page for content
    pdf.addPage();

    // Report Header
    pdf.setFontSize(18);
    pdf.setTextColor(50, 50, 50);
    pdf.text('Security Audit Report', margin, margin);

    pdf.setFontSize(10);
    pdf.setTextColor(100, 100, 100);
    pdf.text(`Report ID: ${reportRef}`, pageWidth - margin, margin, { align: 'right' });
    pdf.text(`Generated by: Chain-Fox`, pageWidth - margin, margin + 6, { align: 'right' });
    pdf.text(`Date: ${completedDate}`, pageWidth - margin, margin + 12, { align: 'right' });

    pdf.line(margin, margin + 15, pageWidth - margin, margin + 15);
    let yPos = margin + 25;

    // Project Overview
    pdf.setFontSize(16);
    pdf.setTextColor(50, 50, 50);
    pdf.text('Overview', margin, yPos);
    yPos += 10;

    pdf.setFontSize(12);
    pdf.text('Project Summary', margin, yPos);
    yPos += 8;

    pdf.setFontSize(10);
    pdf.setTextColor(70, 70, 70);
    pdf.text(`Repository: https://github.com/${report.repo_name}`, margin, yPos);
    yPos += 6;
    pdf.text(`Owner: ${report.user_name}`, margin, yPos);
    yPos += 6;
    pdf.text(`Audit Date: ${auditDate}`, margin, yPos);
    yPos += 6;
    pdf.text(`Completed Date: ${completedDate}`, margin, yPos);
    yPos += 12;

    // Risk Score
    pdf.setFontSize(12);
    pdf.setTextColor(50, 50, 50);
    pdf.text('Risk Score', margin, yPos);
    yPos += 8;

    // Draw score box
    const scoreColor = report.risk_score >= 90 ? [39, 174, 96] :
                      report.risk_score >= 70 ? [52, 152, 219] :
                      report.risk_score >= 50 ? [241, 196, 15] :
                      [231, 76, 60];

    pdf.setFillColor(...scoreColor);
    pdf.roundedRect(margin, yPos, 30, 20, 2, 2, 'F');
    pdf.setTextColor(255, 255, 255);
    pdf.setFontSize(14);
    pdf.text(`${report.risk_score}%`, margin + 15, yPos + 12, { align: 'center' });
    yPos += 25;

    // Vulnerability Summary Table
    pdf.setFontSize(12);
    pdf.setTextColor(50, 50, 50);
    pdf.text('Vulnerability Summary', margin, yPos);
    yPos += 8;

    const tableData = [
      ['Critical', severityCounts.critical.toString()],
      ['High', severityCounts.high.toString()],
      ['Medium', severityCounts.medium.toString()],
      ['Low', severityCounts.low.toString()],
      ['Info', severityCounts.info.toString()]
    ];

    autoTable(pdf, {
      startY: yPos,
      head: [['Severity', 'Count']],
      body: tableData,
      theme: 'grid',
      headStyles: {
        fillColor: [240, 240, 240],
        textColor: [50, 50, 50],
        fontStyle: 'bold'
      },
      alternateRowStyles: {
        fillColor: [250, 250, 250]
      },
      margin: { left: margin, right: margin }
    });

    // Get the final Y position from the last table
    const lastTable = pdf.previousAutoTable || {};
    yPos = (lastTable.finalY || yPos) + 15;

    // Detailed Findings
    pdf.setFontSize(16);
    pdf.setTextColor(50, 50, 50);
    pdf.text('Detailed Findings', margin, yPos);
    yPos += 10;

    // Check if we need to add a new page
    if (yPos > pageHeight - 50) {
      pdf.addPage();
      yPos = margin;
    }

    // If no issues, show a message
    if (Object.entries(issuesByFile).length === 0) {
      pdf.setFillColor(240, 255, 240);
      pdf.roundedRect(margin, yPos, contentWidth, 20, 2, 2, 'F');
      pdf.setTextColor(39, 174, 96);
      pdf.setFontSize(12);
      pdf.text('No issues detected', pageWidth / 2, yPos + 10, { align: 'center' });
      pdf.setTextColor(100, 100, 100);
      pdf.setFontSize(10);
      pdf.text('Scan completed successfully. No security vulnerabilities found.', pageWidth / 2, yPos + 18, { align: 'center' });
      yPos += 25;
    } else {
      // Process each file and its issues
      for (const [filePath, fileIssues] of Object.entries(issuesByFile)) {
        // Check if we need to add a new page
        if (yPos > pageHeight - 60) {
          pdf.addPage();
          yPos = margin;
        }

        // File header
        pdf.setFillColor(240, 248, 255);
        pdf.roundedRect(margin, yPos, contentWidth, 12, 2, 2, 'F');
        pdf.setTextColor(70, 130, 180);
        pdf.setFontSize(11);
        pdf.text(`File: ${filePath}`, margin + 5, yPos + 8);
        pdf.setTextColor(100, 100, 100);
        pdf.text(`Found ${fileIssues.length} ${fileIssues.length === 1 ? 'issue' : 'issues'}`, pageWidth - margin - 5, yPos + 8, { align: 'right' });
        yPos += 18;

        // Process each issue
        for (const issue of fileIssues) {
          // Check if we need to add a new page
          if (yPos > pageHeight - 100) {
            pdf.addPage();
            yPos = margin;
          }

          // Issue box
          pdf.setDrawColor(200, 200, 200);
          pdf.setFillColor(250, 250, 250);
          pdf.roundedRect(margin, yPos, contentWidth, 10, 2, 2, 'FD');

          // Severity indicator
          const severityColor =
            issue.severity?.toLowerCase() === 'critical' ? [231, 76, 60] :
            issue.severity?.toLowerCase() === 'high' ? [230, 126, 34] :
            issue.severity?.toLowerCase() === 'medium' ? [241, 196, 15] :
            issue.severity?.toLowerCase() === 'low' ? [46, 204, 113] :
            [52, 152, 219];

          pdf.setFillColor(...severityColor);
          pdf.roundedRect(margin + 5, yPos + 3, 4, 4, 1, 1, 'F');

          // Issue title
          pdf.setTextColor(50, 50, 50);
          pdf.setFontSize(11);
          pdf.text(issue.issue_type || 'Issue', margin + 15, yPos + 7);

          // Severity text
          pdf.setTextColor(...severityColor);
          pdf.setFontSize(9);
          pdf.text(issue.severity?.toUpperCase() || 'INFO', pageWidth - margin - 5, yPos + 7, { align: 'right' });
          yPos += 15;

          // Issue details
          pdf.setTextColor(70, 70, 70);
          pdf.setFontSize(10);

          if (issue.line_number) {
            pdf.text(`Line: ${issue.line_number}`, margin, yPos);
            yPos += 6;
          }

          // Issue message
          const processedMessage = processText(issue.message);
          yPos = addWrappedText(processedMessage, margin, yPos, contentWidth - 10, 6) + 6;

          // Add a small gap between issues
          yPos += 10;
        }

        // Add space between files
        yPos += 10;
      }
    }

    // Check if we need to add a new page for appendix
    if (yPos > pageHeight - 100) {
      pdf.addPage();
      yPos = margin;
    }

    // Appendix
    pdf.setFontSize(16);
    pdf.setTextColor(50, 50, 50);
    pdf.text('Appendix', margin, yPos);
    yPos += 10;

    pdf.setFontSize(12);
    pdf.text('Disclaimer', margin, yPos);
    yPos += 8;

    pdf.setFontSize(10);
    pdf.setTextColor(70, 70, 70);
    const disclaimer = 'This audit report is not an endorsement or indictment of any particular project or team, and the report does not guarantee the security of any particular project. This audit report represents a limited review of the code at a point in time and is not comprehensive in scope.';
    yPos = addWrappedText(disclaimer, margin, yPos, contentWidth, 6) + 6;

    const disclaimer2 = 'Security assessments cannot uncover all vulnerabilities and are not guarantees of software security. Projects should always implement thorough testing and auditing practices beyond this report.';
    yPos = addWrappedText(disclaimer2, margin, yPos, contentWidth, 6) + 10;

    pdf.setFontSize(12);
    pdf.setTextColor(50, 50, 50);
    pdf.text('Methodology', margin, yPos);
    yPos += 8;

    pdf.setFontSize(10);
    pdf.setTextColor(70, 70, 70);
    const methodology = 'Our security assessment was conducted using a combination of manual code review and automated tools. The audit focused on identifying security vulnerabilities, code quality issues, and adherence to best practices.';
    yPos = addWrappedText(methodology, margin, yPos, contentWidth, 6) + 6;

    const methodology2 = 'Areas of focus included but were not limited to: access control, input validation, error handling, authorization, authentication, data protection, and contract interactions.';
    yPos = addWrappedText(methodology2, margin, yPos, contentWidth, 6) + 10;

    // Footer on all pages
    const totalPages = pdf.internal.getNumberOfPages();
    for (let i = 1; i <= totalPages; i++) {
      pdf.setPage(i);
      pdf.setFontSize(8);
      pdf.setTextColor(150, 150, 150);
      pdf.text(`© ${new Date().getFullYear()} Chain-Fox. All rights reserved.`, pageWidth / 2, pageHeight - 10, { align: 'center' });
      pdf.text(`Page ${i} of ${totalPages}`, pageWidth - margin, pageHeight - 10, { align: 'right' });
    }

    // Add metadata
    pdf.setProperties({
      title: filename.replace('.pdf', ''),
      subject: 'Security Audit Report',
      author: 'Chain Fox',
      keywords: 'security, audit, blockchain, smart contract',
      creator: 'Chain Fox Security Audit Platform'
    });

    // Save the PDF
    pdf.save(filename);

    // Call success callback if provided
    if (options.onComplete) {
      options.onComplete();
    }

    return true;
  } catch (error) {
    console.error('Error generating PDF:', error);

    // Call error callback if provided
    if (options.onError) {
      options.onError({
        message: 'Failed to generate PDF: ' + (error.message || 'Unknown error'),
        originalError: error,
        details: 'An error occurred during direct PDF generation'
      });
    }

    return false;
  }
};

export default {
  exportReportToPDF
};
